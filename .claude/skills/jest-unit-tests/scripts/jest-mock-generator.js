// jest-mock-generator.js
// Description: Generates boilerplate mock files for modules or classes,
//              streamlining the process of creating test doubles.
// Usage: node jest-mock-generator.js <source_file_path> [--output-dir <dir>]
//
// Options:
//   --output-dir <dir>  Specify the directory where the mock file should be created.
//                       Defaults to a '__mocks__/' subdirectory relative to the source file.
//   --help              Display this help message.

const fs = require('fs');
const path = require('path');
const { program } = require('commander');

// --- Configuration Variables ---
const COLOR_RESET = "\x1b[0m";
const COLOR_RED = "\x1b[31m";
const COLOR_GREEN = "\x1b[32m";
const COLOR_YELLOW = "\x1b[33m";
const COLOR_BLUE = "\x1b[34m";

// --- Helper Functions ---
function logInfo(message) {
  console.log(`${COLOR_BLUE}[INFO]${COLOR_RESET} ${message}`);
}

function logSuccess(message) {
  console.log(`${COLOR_GREEN}[SUCCESS]${COLOR_RESET} ${message}`);
}

function logWarning(message) {
  console.log(`${COLOR_YELLOW}[WARNING]${COLOR_RESET} ${message}`);
}

function logError(message) {
  console.error(`${COLOR_RED}[ERROR]${COLOR_RESET} ${message}`);
  process.exit(1);
}

function generateMockContent(sourceFileName, exports) {
  const mockExports = exports.map(exp => {
    // Simple heuristic: if it looks like a class or function, mock it as a Jest mock function
    if (exp.startsWith('class ') || exp.startsWith('function ')) {
      const name = exp.split(' ')[1];
      return `export const ${name} = jest.fn();`;
    } else if (exp.startsWith('const ')) {
      const name = exp.split(' ')[1];
      return `export const ${name} = jest.fn(); // Mock const functions/variables`;
    } else {
      return `export const ${exp} = jest.fn(); // Default to mock function`;
    }
  }).join('\n');

  return `// __mocks__/${sourceFileName}
// Generated by jest-mock-generator.js

${mockExports}
`;
}

function extractExports(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const exports = [];

  // Regex to find named exports (functions, classes, consts)
  const namedExportsRegex = /^(?:export\s+)?(?:async\s+)?(const|let|var|function|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)/gm;
  let match;
  while ((match = namedExportsRegex.exec(content)) !== null) {
    // Ensure it's an actual export, not just a declaration
    if (content.substring(match.index - 7, match.index).includes('export')) {
      exports.push(`${match[1]} ${match[2]}`);
    }
  }

  // Regex to find default exports (simple case)
  const defaultExportRegex = /export\s+default\s+([a-zA-Z_][a-zA-Z0-9_]*)/;
  match = content.match(defaultExportRegex);
  if (match) {
    exports.push(`default ${match[1]}`);
  }

  return exports;
}

// --- Main Logic ---
function main() {
  program
    .argument('<source_file_path>', 'Path to the source file for which to generate a mock.')
    .option('-o, --output-dir <dir>', 'Specify the directory where the mock file should be created.')
    .action((sourceFilePath, options) => {
      const absoluteSourceFilePath = path.resolve(sourceFilePath);

      if (!fs.existsSync(absoluteSourceFilePath)) {
        logError(`Source file not found: ${absoluteSourceFilePath}`);
      }

      const sourceDir = path.dirname(absoluteSourceFilePath);
      const sourceFileName = path.basename(absoluteSourceFilePath);
      const baseName = path.basename(sourceFileName, path.extname(sourceFileName));

      const outputDir = options.outputDir ? path.resolve(options.outputDir) : path.join(sourceDir, '__mocks__');

      fs.mkdirSync(outputDir, { recursive: true });

      const mockFileName = sourceFileName;
      const mockFilePath = path.join(outputDir, mockFileName);

      if (fs.existsSync(mockFilePath)) {
        logWarning(`Mock file already exists: ${mockFilePath}. Skipping creation.`);
        return;
      }

      logInfo(`Extracting exports from ${sourceFileName}...`);
      const exports = extractExports(absoluteSourceFilePath);

      if (exports.length === 0) {
        logWarning(`No named or default exports found in ${sourceFileName}. Generating an empty mock file.`);
      }

      const mockContent = generateMockContent(sourceFileName, exports);

      fs.writeFileSync(mockFilePath, mockContent, 'utf-8');
      logSuccess(`Generated mock file: ${mockFilePath}`);
      logInfo(`Detected exports: ${exports.length > 0 ? exports.join(', ') : 'None'}.`);
      logInfo("Remember to customize the mock's behavior as needed.");
    });

  program.parse(process.argv);
}

if (require.main === module) {
  main();
}
