#!/usr/bin/env python3
"""
generate_fixture_boilerplate.py

This script generates a basic pytest fixture boilerplate in a conftest.py file.
It allows specifying the fixture name, scope, and whether to include teardown logic.

Usage Examples:
    # Generate a function-scoped fixture named 'my_fixture' without teardown
    python generate_fixture_boilerplate.py my_fixture

    # Generate a session-scoped fixture named 'db_session' with teardown
    python generate_fixture_boilerplate.py db_session --scope session --teardown

    # Generate a module-scoped fixture named 'api_client' with teardown and dry-run
    python generate_fixture_boilerplate.py api_client -s module -t --dry-run

    # Generate a fixture in a specific conftest.py path
    python generate_fixture_boilerplate.py temp_file --conftest-path tests/integration/conftest.py
"""

import argparse
import os
import sys
from datetime import datetime

# Optional: For colored output
try:
    from colorama import Fore, Style, init
    init(autoreset=True)
except ImportError:
    class Color:
        def __getattr__(self, name):
            return ''
    Fore = Color()
    Style = Color()

def generate_fixture_code(fixture_name, scope, with_teardown):
    """Generates the Python code for a pytest fixture."""
    teardown_code = """
    # Teardown logic here (e.g., close connection, delete file)
    print(f"{Fore.YELLOW}Teardown for {fixture_name} (scope: {scope})...{Style.RESET_ALL}")
    """ if with_teardown else "" ""

    code = f"""
@pytest.fixture(scope="{scope}")
def {fixture_name}():
    """
    A pytest fixture for {fixture_name}.
    Scope: {scope}.
    """
    print(f"{Fore.GREEN}Setup for {fixture_name} (scope: {scope})...{Style.RESET_ALL}")
    # Setup logic here (e.g., create object, open file)
    resource = f"<{fixture_name}_resource>"
    yield resource
    {teardown_code}
"""
    return code

def main():
    parser = argparse.ArgumentParser(
        description="Generate pytest fixture boilerplate.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "fixture_name",
        help="The name of the fixture to generate (e.g., 'my_fixture')."
    )
    parser.add_argument(
        "-s", "--scope",
        choices=["function", "class", "module", "session"],
        default="function",
        help="The scope of the fixture (default: function)."
    )
    parser.add_argument(
        "-t", "--teardown",
        action="store_true",
        help="Include teardown logic using 'yield'."
    )
    parser.add_argument(
        "--conftest-path",
        default="conftest.py",
        help="Path to the conftest.py file (default: conftest.py in current directory)."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the generated code and file path without writing to disk."
    )

    args = parser.parse_args()

    fixture_code = generate_fixture_code(
        args.fixture_name,
        args.scope,
        args.teardown
    )

    header = f"\n# Generated by generate_fixture_boilerplate.py on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    full_content = header + fixture_code

    if args.dry_run:
        print(f"{Fore.CYAN}--- DRY RUN: Generated Fixture Code ---{Style.RESET_ALL}")
        print(f"Target file: {args.conftest_path}")
        print(full_content)
        print(f"{Fore.CYAN}--------------------------------------{Style.RESET_ALL}")
    else:
        try:
            mode = 'a' if os.path.exists(args.conftest_path) else 'w'
            with open(args.conftest_path, mode) as f:
                f.write(full_content)
            print(f"{Fore.GREEN}Successfully {'appended to' if mode == 'a' else 'created'} '{args.conftest_path}' with fixture '{args.fixture_name}'.{Style.RESET_ALL}")
            print(f"{Fore.BLUE}Remember to add 'import pytest' to '{args.conftest_path}' if it's not already there.{Style.RESET_ALL}")
        except IOError as e:
            print(f"{Fore.RED}Error writing to file '{args.conftest_path}': {e}{Style.RESET_ALL}", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()
