#!/usr/bin/env python3
"""
Next.js Pages Router Page Generator

Generates Next.js page files with proper data fetching methods and TypeScript types.
Supports SSG (getStaticProps), SSR (getServerSideProps), dynamic routes, and ISR.

Usage:
    python page-generator.py --path pages/blog/[slug].tsx --type ssg --dynamic
    python page-generator.py --path pages/dashboard.tsx --type ssr --auth
    python page-generator.py --interactive

Examples:
    # Generate a static blog post page with ISR
    python page-generator.py -p pages/posts/[id].tsx -t ssg -d --isr 60

    # Generate an authenticated dashboard with SSR
    python page-generator.py -p pages/dashboard.tsx -t ssr -a

    # Interactive mode (recommended for beginners)
    python page-generator.py -i

Author: DevDev AI
Version: 1.0.0
"""

import argparse
import os
import sys
import re
from pathlib import Path
from typing import Optional, List, Dict

# Color codes for terminal output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_success(msg: str):
    print(f"{Colors.OKGREEN}✓ {msg}{Colors.ENDC}")

def print_error(msg: str):
    print(f"{Colors.FAIL}✗ {msg}{Colors.ENDC}", file=sys.stderr)

def print_warning(msg: str):
    print(f"{Colors.WARNING}⚠ {msg}{Colors.ENDC}")

def print_info(msg: str):
    print(f"{Colors.OKBLUE}ℹ {msg}{Colors.ENDC}")


def is_dynamic_route(path: str) -> bool:
    """Check if the path contains dynamic segments."""
    return '[' in path and ']' in path


def extract_route_params(path: str) -> List[str]:
    """Extract dynamic parameters from a route path."""
    return re.findall(r'\[([^\]]+)\]', path)


def get_component_name(path: str) -> str:
    """Generate component name from file path."""
    filename = Path(path).stem
    # Remove brackets from dynamic routes
    filename = re.sub(r'[\[\].]', '', filename)
    # Capitalize first letter and convert to PascalCase
    if filename == 'index':
        parent_dir = Path(path).parent.name
        return parent_dir.capitalize() + 'Page' if parent_dir != 'pages' else 'HomePage'
    return filename.capitalize() + 'Page'


def generate_ssg_page(
    component_name: str,
    route_params: List[str],
    isr: Optional[int],
    auth: bool,
    catch_all: bool
) -> str:
    """Generate SSG page with getStaticProps and getStaticPaths."""

    param_type = 'string[]' if catch_all else 'string'
    param_name = route_params[0] if route_params else 'id'

    template = f"""// Generated by page-generator.py
import {{ GetStaticProps, GetStaticPaths }} from 'next';
{"import { useRouter } from 'next/router';" if not route_params else ""}

// Type definitions
interface {component_name}Props {{
  // TODO: Define your prop types
  data: any;
}}

{f'''// This page runs at BUILD TIME
// Generated HTML is cached and reused on each request
// ISR revalidation: {isr} seconds
''' if isr else '// This page runs at BUILD TIME only\n// Generated HTML is cached and reused on each request\n'}
export const getStaticProps: GetStaticProps<{component_name}Props> = async (context) => {{
  const {{ params }} = context;
{f"  const {param_name} = params?.{param_name} as {param_type};" if route_params else ""}

  try {{
    // TODO: Fetch your data here
    // Example: const data = await fetch(`https://api.example.com/items/${{id}}`).then(r => r.json());
    const data = {{}};

{'''    // Check if data exists
    if (!data) {
      return {
        notFound: true,
      };
    }
''' if route_params else ''}
    return {{
      props: {{
        data,
      }},{f'''
      // ISR: Revalidate every {isr} seconds
      revalidate: {isr},''' if isr else ''}
    }};
  }} catch (error) {{
    console.error('Error fetching data:', error);
    return {{
      notFound: true,
    }};
  }}
}};
{f'''
export const getStaticPaths: GetStaticPaths = async () => {{
  try {{
    // TODO: Fetch all possible paths
    // For large datasets, only pre-render the most popular items
    // Example:
    // const items = await fetch('https://api.example.com/items/top?limit=100').then(r => r.json());

    const items: any[] = [];

    const paths = items.map((item) => ({{
      params: {{ {param_name}: item.{param_name} }},
    }}));

    return {{
      paths,
      // 'blocking': Generate pages on-demand if not pre-rendered (recommended)
      // 'true': Show fallback UI while generating
      // 'false': Return 404 for paths not in paths array
      fallback: 'blocking',
    }};
  }} catch (error) {{
    console.error('Error generating paths:', error);
    return {{
      paths: [],
      fallback: 'blocking',
    }};
  }}
}};
''' if route_params else ''}
export default function {component_name}({{ data }}: {component_name}Props) {{
{"  const router = useRouter();" if not route_params else ""}
{f'''
  // If the page is not yet generated, this will be displayed
  // initially until getStaticProps() finishes running
  if (router.isFallback) {{
    return <div>Loading...</div>;
  }}
''' if route_params and isr else ''}
  return (
    <div>
      <h1>{component_name}</h1>
      {{/* TODO: Render your component */}}
      <pre>{{JSON.stringify(data, null, 2)}}</pre>
    </div>
  );
}}
"""
    return template


def generate_ssr_page(
    component_name: str,
    route_params: List[str],
    auth: bool,
) -> str:
    """Generate SSR page with getServerSideProps."""

    param_name = route_params[0] if route_params else 'id'

    auth_import = "\nimport { getSession } from 'next-auth/react';" if auth else ""

    template = f"""// Generated by page-generator.py
import {{ GetServerSideProps }} from 'next';{auth_import}

// Type definitions
interface {component_name}Props {{
  // TODO: Define your prop types
  data: any;{'''
  user: {
    name: string;
    email: string;
  };''' if auth else ''}
}}

// This page runs on EVERY REQUEST (server-side)
// Use this when data must be fresh or when checking authentication
export const getServerSideProps: GetServerSideProps<{component_name}Props> = async (context) => {{
  const {{ req, res, query, params }} = context;
{f"  const {param_name} = params?.{param_name} as string;" if route_params else ""}
{'''
  // Check authentication
  const session = await getSession({ req });

  if (!session) {
    return {
      redirect: {
        destination: '/login',
        permanent: false,
      },
    };
  }
''' if auth else ''}
  try {{
    // TODO: Fetch your data here
    // You can use request headers, cookies, etc.
    // Example: const data = await fetch(`https://api.example.com/items/${{id}}`, {{
    //   headers: {{ Cookie: req.headers.cookie || '' }},
    // }}).then(r => r.json());

    const data = {{}};

    // Optional: Set cache headers for CDN caching
    // res.setHeader(
    //   'Cache-Control',
    //   'public, s-maxage=10, stale-while-revalidate=59'
    // );

    return {{
      props: {{
        data,{'''
        user: session.user,''' if auth else ''}
      }},
    }};
  }} catch (error) {{
    console.error('Error fetching data:', error);
    return {{
      notFound: true,
    }};
  }}
}};

export default function {component_name}({{ data{', user' if auth else ''} }}: {component_name}Props) {{
  return (
    <div>
      <h1>{component_name}</h1>{'''
      <p>Welcome, {{user.name}}!</p>''' if auth else ''}
      {{/* TODO: Render your component */}}
      <pre>{{JSON.stringify(data, null, 2)}}</pre>
    </div>
  );
}}
"""
    return template


def generate_client_page(component_name: str) -> str:
    """Generate client-side rendered page."""

    template = f"""// Generated by page-generator.py
import {{ useEffect, useState }} from 'react';

// Type definitions
interface {component_name}Data {{
  // TODO: Define your data type
  [key: string]: any;
}}

export default function {component_name}() {{
  const [data, setData] = useState<{component_name}Data | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {{
    // TODO: Fetch your data here
    fetch('/api/your-endpoint')
      .then((res) => {{
        if (!res.ok) throw new Error('Failed to fetch');
        return res.json();
      }})
      .then((data) => {{
        setData(data);
        setLoading(false);
      }})
      .catch((err) => {{
        setError(err.message);
        setLoading(false);
      }});
  }}, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {{error}}</div>;
  if (!data) return <div>No data</div>;

  return (
    <div>
      <h1>{component_name}</h1>
      {{/* TODO: Render your component */}}
      <pre>{{JSON.stringify(data, null, 2)}}</pre>
    </div>
  );
}}
"""
    return template


def interactive_mode() -> Dict:
    """Interactive mode for generating pages."""
    print(f"\n{Colors.BOLD}Next.js Page Generator - Interactive Mode{Colors.ENDC}\n")

    # Get file path
    while True:
        path = input("Enter the page path (e.g., pages/blog/[slug].tsx): ").strip()
        if path:
            break
        print_error("Path cannot be empty")

    # Detect if dynamic
    is_dynamic = is_dynamic_route(path)
    if is_dynamic:
        print_info(f"Detected dynamic route with parameters: {', '.join(extract_route_params(path))}")

    # Get page type
    print("\nSelect page type:")
    print("  1. SSG (Static Site Generation) - Pre-rendered at build time")
    print("  2. SSR (Server-Side Rendering) - Rendered on each request")
    print("  3. Client - Client-side rendered only")

    while True:
        page_type = input("Enter choice (1-3): ").strip()
        if page_type in ['1', '2', '3']:
            page_type = {'1': 'ssg', '2': 'ssr', '3': 'client'}[page_type]
            break
        print_error("Invalid choice")

    # ISR option for SSG
    isr = None
    if page_type == 'ssg':
        isr_input = input("Enable ISR? Enter revalidation time in seconds (or press Enter to skip): ").strip()
        if isr_input:
            try:
                isr = int(isr_input)
                if isr < 1:
                    print_warning("ISR value should be >= 1. Setting to 60 seconds.")
                    isr = 60
            except ValueError:
                print_warning("Invalid ISR value. Skipping ISR.")

    # Auth option
    auth = False
    if page_type in ['ssg', 'ssr']:
        auth_input = input("Require authentication? (y/N): ").strip().lower()
        auth = auth_input == 'y'

    # Dry run option
    dry_run_input = input("Dry run (preview without creating file)? (y/N): ").strip().lower()
    dry_run = dry_run_input == 'y'

    return {
        'path': path,
        'type': page_type,
        'isr': isr,
        'auth': auth,
        'dry_run': dry_run,
    }


def main():
    parser = argparse.ArgumentParser(
        description='Generate Next.js Pages Router page files with proper data fetching methods.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Generate a static blog post page with ISR
  %(prog)s -p pages/posts/[id].tsx -t ssg -d --isr 60

  # Generate an authenticated dashboard with SSR
  %(prog)s -p pages/dashboard.tsx -t ssr -a

  # Interactive mode (recommended)
  %(prog)s -i
        '''
    )

    parser.add_argument('-p', '--path', help='Page file path (e.g., pages/blog/[slug].tsx)')
    parser.add_argument('-t', '--type', choices=['ssg', 'ssr', 'client'],
                        help='Page type: ssg (Static), ssr (Server-Side), client (Client-Side)')
    parser.add_argument('-d', '--dynamic', action='store_true',
                        help='Generate getStaticPaths for dynamic routes (auto-detected if path has brackets)')
    parser.add_argument('--isr', type=int, metavar='SECONDS',
                        help='Enable ISR with revalidation time in seconds (for SSG only)')
    parser.add_argument('-a', '--auth', action='store_true',
                        help='Include authentication check (requires next-auth)')
    parser.add_argument('-i', '--interactive', action='store_true',
                        help='Interactive mode with prompts')
    parser.add_argument('--dry-run', action='store_true',
                        help='Preview output without creating file')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Overwrite existing file')

    args = parser.parse_args()

    # Interactive mode
    if args.interactive:
        config = interactive_mode()
        args.path = config['path']
        args.type = config['type']
        args.isr = config['isr']
        args.auth = config['auth']
        args.dry_run = config['dry_run']

    # Validate arguments
    if not args.path:
        parser.error("--path is required (or use --interactive)")
    if not args.type:
        parser.error("--type is required (or use --interactive)")

    # Auto-detect dynamic routes
    route_params = extract_route_params(args.path)
    is_catch_all = any('...' in param for param in route_params)

    if route_params and not args.dynamic:
        print_info(f"Auto-detected dynamic route with parameters: {', '.join(route_params)}")
        args.dynamic = True

    # Validate ISR
    if args.isr and args.type != 'ssg':
        print_warning("ISR only works with SSG pages. Ignoring --isr flag.")
        args.isr = None

    if args.isr and args.isr < 1:
        print_warning("ISR revalidation time should be >= 1 second. Setting to 60.")
        args.isr = 60

    # Generate component name
    component_name = get_component_name(args.path)

    # Generate page content
    if args.type == 'ssg':
        content = generate_ssg_page(component_name, route_params, args.isr, args.auth, is_catch_all)
    elif args.type == 'ssr':
        content = generate_ssr_page(component_name, route_params, args.auth)
    else:  # client
        content = generate_client_page(component_name)

    # Dry run - just print the content
    if args.dry_run:
        print(f"\n{Colors.BOLD}Preview of {args.path}:{Colors.ENDC}\n")
        print(content)
        print(f"\n{Colors.OKCYAN}This is a dry run. No file was created.{Colors.ENDC}")
        return

    # Check if file exists
    file_path = Path(args.path)
    if file_path.exists() and not args.force:
        print_error(f"File already exists: {args.path}")
        print_info("Use --force to overwrite or choose a different path")
        sys.exit(1)

    # Create directory if it doesn't exist
    file_path.parent.mkdir(parents=True, exist_ok=True)

    # Write file
    try:
        file_path.write_text(content)
        print_success(f"Created {args.path}")
        print_info(f"Component: {component_name}")
        print_info(f"Type: {args.type.upper()}")
        if args.isr:
            print_info(f"ISR revalidation: {args.isr} seconds")
        if args.auth:
            print_info("Authentication: enabled")
        if route_params:
            print_info(f"Dynamic parameters: {', '.join(route_params)}")

        print(f"\n{Colors.OKGREEN}Next steps:{Colors.ENDC}")
        print("  1. Update the TODO comments in the generated file")
        print("  2. Define your prop types")
        print("  3. Implement data fetching logic")
        print("  4. Build your component UI")

    except Exception as e:
        print_error(f"Failed to create file: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
