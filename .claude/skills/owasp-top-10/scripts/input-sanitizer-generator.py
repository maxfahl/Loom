import argparse
import sys

# ANSI escape codes for colored output
COLOR_GREEN = '\033[92m'
COLOR_RED = '\033[91m'
COLOR_YELLOW = '\033[93m'
COLOR_BLUE = '\033[94m'
COLOR_RESET = '\033[0m'

def generate_sanitizer_code(
    input_type: str,
    max_length: int | None = None,
    min_length: int | None = None,
    pattern: str | None = None,
    output_file: str | None = None,
) -> None:
    """
    Generates boilerplate TypeScript code for input sanitization and validation.

    Args:
        input_type: The type of input to generate sanitizer for (e.g., 'string', 'email', 'number', 'url').
        max_length: Optional maximum length for string inputs.
        min_length: Optional minimum length for string inputs.
        pattern: Optional regex pattern for string inputs.
        output_file: Optional. The file path to write the TypeScript output to. If None, prints to stdout.
    """
    print(f"{COLOR_BLUE}--- Input Sanitizer Code Generator ---{COLOR_RESET}")
    print(f"Generating for type: {COLOR_YELLOW}{input_type}{COLOR_RESET}")
    if max_length: print(f"Max Length: {COLOR_YELLOW}{max_length}{COLOR_RESET}")
    if min_length: print(f"Min Length: {COLOR_YELLOW}{min_length}{COLOR_RESET}")
    if pattern: print(f"Pattern: {COLOR_YELLOW}{pattern}{COLOR_RESET}")
    print("--------------------------------------")

    code_template = """
# Generated by input-sanitizer-generator.py
# For OWASP Top 10: A03:2021-Injection, A07:2021-Cross-Site Scripting (XSS)

/**
 * Sanitizes and validates a {input_type} input.
 * @param input The raw input string.
 * @returns A sanitized and validated {input_type} string, or null if invalid.
 */
export function sanitize{function_name}(input: string | null | undefined): string | null {
  if (input === null || input === undefined) {
    return null;
  }

  let sanitizedInput = String(input).trim();

{validation_rules}

  return sanitizedInput;
}
"""

    validation_rules = []
    function_name = input_type.capitalize()

    if input_type == "string":
        validation_rules.append("  // Basic HTML escaping to prevent XSS
  sanitizedInput = sanitizedInput.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\'/g, '&#x27;');")
        if min_length is not None:
            validation_rules.append(f"  if (sanitizedInput.length < {min_length}) {{
    console.warn('Input too short.');
    return null;
  }}")
        if max_length is not None:
            validation_rules.append(f"  if (sanitizedInput.length > {max_length}) {{
    console.warn('Input too long.');
    return null;
  }}")
        if pattern:
            validation_rules.append(f"  // Custom regex pattern validation
  const regex = new RegExp(`{pattern}`);
  if (!regex.test(sanitizedInput)) {{
    console.warn('Input does not match required pattern.');
    return null;
  }}")

    elif input_type == "email":
        function_name = "Email"
        validation_rules.append("  // Basic email format validation (more robust validation might require a library)
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  if (!emailRegex.test(sanitizedInput)) {{
    console.warn('Invalid email format.');
    return null;
  }}")
        if max_length is not None:
            validation_rules.append(f"  if (sanitizedInput.length > {max_length}) {{
    console.warn('Email too long.');
    return null;
  }}")

    elif input_type == "number":
        function_name = "Number"
        validation_rules.append("  // Ensure it's a valid number
  if (!/^-?\\d+(\\.\\d+)?$/.test(sanitizedInput)) {{
    console.warn('Invalid number format.');
    return null;
  }}
  // Convert to number and back to string to normalize
  sanitizedInput = String(Number(sanitizedInput));")
        if min_length is not None:
            validation_rules.append(f"  if (Number(sanitizedInput) < {min_length}) {{
    console.warn('Number is too small.');
    return null;
  }}")
        if max_length is not None:
            validation_rules.append(f"  if (Number(sanitizedInput) > {max_length}) {{
    console.warn('Number is too large.');
    return null;
  }}")

    elif input_type == "url":
        function_name = "Url"
        validation_rules.append("  // Basic URL validation (more robust validation might require a library)
  try {
    const url = new URL(sanitizedInput);
    // Optionally restrict schemes, hosts, etc.
    if (!('http:' === url.protocol || 'https:' === url.protocol)) {
      console.warn('Only HTTP/HTTPS URLs are allowed.');
      return null;
    }
    sanitizedInput = url.toString(); // Normalize URL
  } catch (e) {
    console.warn('Invalid URL format.', e);
    return null;
  }")
        if max_length is not None:
            validation_rules.append(f"  if (sanitizedInput.length > {max_length}) {{
    console.warn('URL too long.');
    return null;
  }}")

    else:
        print(f"{COLOR_RED}Error: Unsupported input type '{input_type}'. Supported types: string, email, number, url.{COLOR_RESET}")
        sys.exit(1)

    final_code = code_template.format(
        input_type=input_type,
        function_name=function_name,
        validation_rules="\n".join(validation_rules)
    )

    if output_file:
        try:
            with open(output_file, "w") as f:
                f.write(final_code)
            print(f"{COLOR_GREEN}Sanitizer code successfully written to {output_file}{COLOR_RESET}")
        except IOError as e:
            print(f"{COLOR_RED}Error writing to file {output_file}: {e}{COLOR_RESET}")
            sys.exit(1)
    else:
        print(f"{COLOR_GREEN}\n--- Generated Sanitizer Code ---{COLOR_RESET}")
        print(final_code)
        print(f"{COLOR_GREEN}--------------------------------{COLOR_RESET}")

def main():
    parser = argparse.ArgumentParser(
        description="Generates boilerplate TypeScript code for input sanitization and validation.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "--type",
        type=str,
        choices=["string", "email", "number", "url"],
        required=True,
        help="The type of input to generate sanitizer for (e.g., 'string', 'email', 'number', 'url').",
    )
    parser.add_argument(
        "--max-length",
        type=int,
        help="Optional maximum length for string/email/url inputs.",
    )
    parser.add_argument(
        "--min-length",
        type=int,
        help="Optional minimum length for string/number inputs.",
    )
    parser.add_argument(
        "--pattern",
        type=str,
        help="Optional regex pattern for string inputs (e.g., '^[a-zA-Z0-9]+$').",
    )
    parser.add_argument(
        "--output-file",
        type=str,
        help="Optional. The file path to write the TypeScript output to. If not provided, prints to stdout.",
    )

    args = parser.parse_args()

    generate_sanitizer_code(
        input_type=args.type,
        max_length=args.max_length,
        min_length=args.min_length,
        pattern=args.pattern,
        output_file=args.output_file,
    )

if __name__ == "__main__":
    main()
