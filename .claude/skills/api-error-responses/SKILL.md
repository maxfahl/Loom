---
name: api-error-responses
description: Design and implement consistent, informative API error responses following RFC 9457 Problem Details standard for HTTP APIs.
---


### 2. Skill Purpose

This skill allows Claude to create consistent, informative, and standardized error responses for HTTP APIs. By adhering to the RFC 9457 "Problem Details" standard, Claude can ensure that API errors are both machine-readable for automated systems and human-readable for developers, improving the overall developer experience and simplifying debugging.

### 3. When to Activate This Skill

Activate this skill when the user's request involves any of the following:

- Designing or implementing error handling for a new or existing API.
- A user asks: "How should I structure my API errors?" or "What's the best way to return errors from my API?"
- Reviewing or refactoring existing error handling code.
- Standardizing error responses across multiple microservices or endpoints.
- Seeing inconsistent or poor error responses like `{"error": "Something went wrong"}`.
- Discussing HTTP status codes and their appropriate use in error scenarios.
- Implementing validation logic that results in user-facing errors (e.g., in Express, NestJS, FastAPI).

### 4. Core Knowledge

The core of this skill is **RFC 9457: Problem Details for HTTP APIs**, which supersedes RFC 7807. It defines a standard JSON object (`application/problem+json`) for returning error details.

**Key Fields of a Problem Details Object:**

| Member     | Type    | Description                                                                                             |
|------------|---------|---------------------------------------------------------------------------------------------------------|
| `type`     | string  | A URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable documentation. Defaults to `about:blank`. |
| `title`    | string  | A short, human-readable summary of the problem type. It should not change from occurrence to occurrence. |
| `status`   | number  | The HTTP status code generated by the origin server for this occurrence of the problem.                 |
| `detail`   | string  | A human-readable explanation specific to this occurrence of the problem. May vary between occurrences.  |
| `instance` | string  | A URI that identifies the specific occurrence of the problem. This can be used for logging and tracing. |

**Extension Members:**

The Problem Details object can be extended with additional members to provide more specific information. Common extensions include:

- `invalid-params`: An array of objects detailing validation errors.
- `traceId`: A correlation ID for tracking the request through logs.
- `errors`: A more general-purpose array or object for multiple errors.

**Example (TypeScript Interface):**

```typescript
/**
 * Represents a Problem Details object as defined by RFC 9457.
 */
interface ProblemDetails {
  /**
   * A URI reference that identifies the problem type.
   * @see https://tools.ietf.org/html/rfc9457#section-3.1
   */
  type: string;

  /**
   * A short, human-readable summary of the problem type.
   * @see https://tools.ietf.org/html/rfc9457#section-3.1
   */
  title: string;

  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   * @see https://tools.ietf.org/html/rfc9457#section-3.1
   */
  status: number;

  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @see https://tools.ietf.org/html/rfc9457#section-3.1
   */
  detail?: string;

  /**
   * A URI reference that identifies the specific occurrence of the problem.
   * @see https://tools.ietf.org/html/rfc9457#section-3.1
   */
  instance?: string;

  /**
   * Extension members for additional details.
   */
  [key: string]: any;
}
```

### 5. Key Guidance for Claude

#### ✅ Always Recommend

- **Use RFC 9457**: Standardize on the `application/problem+json` content type and the Problem Details object structure.
- **Use Specific HTTP Status Codes**: Map errors to the most appropriate 4xx (client) or 5xx (server) status code. Don't just default to 400 or 500.
- **Provide a `type` URI**: Even if it's just a link to a documentation page (e.g., `/docs/errors/validation-error`), this is crucial for machine-readability.
- **Include a Correlation ID**: Add a `traceId` or `correlationId` as an extension member to help with debugging across services.
- **Document Your Error `type`s**: The `type` URI should resolve to a page that explains what the error means and how to solve it.
- **Handle Content Negotiation**: Check the client's `Accept` header. If they accept `application/problem+json`, use it. If not, fall back to a default JSON or other format, but still maintain a consistent structure.
- **For Validation Errors**: Use a `422 Unprocessable Entity` status and include an `invalid-params` extension member detailing which fields failed and why.

#### ❌ Never Recommend

- **Don't Expose Sensitive Information**: Never include stack traces, database queries, internal file paths, or secrets in an error response.
- **Don't Use a 2xx Status for Errors**: Errors must use 4xx or 5xx status codes.
- **Avoid Vague Error Messages**: `{"error": "An error occurred"}` is useless. The `detail` field should be specific.
- **Don't Invent a Custom Error Schema**: Stick to the RFC 9457 standard unless there's a compelling, documented reason not to.
- **Don't Put Core Error Information in Headers**: The response body is the place for error details. Headers can supplement (e.g., `Retry-After`), but not replace the body.

#### Common Questions & Responses

- **Q: "Why not just use a simple `{ "error": "message" }` format?"**
  - **A:** "While simple, a custom format lacks standardization. RFC 9457 provides a standard, machine-readable way for clients to handle errors programmatically. It allows for richer details like documentation links (`type`) and specific occurrence identifiers (`instance`), which makes debugging much easier and enables generic error handling libraries."

- **Q: "When should I use 400 vs. 422?"**
  - **A:** "Use `400 Bad Request` for malformed requests where the server cannot even parse the payload (e.g., invalid JSON). Use `422 Unprocessable Entity` when the request syntax is valid, but the server cannot process it due to semantic errors (e.g., a required field is missing, or a value is out of range). The 422 response should ideally include details on which fields are invalid."

- **Q: "How should I handle multiple errors at once?"**
  - **A:** "This is a great use case for an extension member. The primary `title` and `detail` can provide a summary, while an `errors` or `invalid-params` array can list each individual issue. For example, for a form with multiple validation errors, you'd return a single 422 response with a list of all the invalid fields."

### 6. Anti-Patterns to Flag

#### Anti-Pattern 1: Vague, Unstructured Error

```typescript
// ❌ BAD: Unstructured, vague, and uses a 200 OK status for an error.
app.post('/users', (req, res) => {
  if (!req.body.email) {
    res.status(200).json({ success: false, message: 'Email is required' });
  }
  // ...
});
```

```typescript
// ✅ GOOD: Uses a 422 status, RFC 9457 structure, and provides specific details.
app.post('/users', (req, res) => {
  if (!req.body.email) {
    const problem: ProblemDetails = {
      type: '/errors/validation-error',
      title: 'Validation Error',
      status: 422,
      detail: 'One or more fields did not pass validation.',
      instance: req.originalUrl,
      'invalid-params': [
        {
          name: 'email',
          reason: 'Email is a required field.',
        },
      ],
    };
    res.status(422).contentType('application/problem+json').json(problem);
  }
  // ...
});
```

#### Anti-Pattern 2: Exposing Internal Details

```typescript
// ❌ BAD: Leaking stack trace information in a production environment.
app.use((err, req, res, next) => {
  res.status(500).json({
    error: 'Internal Server Error',
    message: err.message,
    stack: err.stack, // <-- DANGEROUS!
  });
});
```

```typescript
// ✅ GOOD: Provides a generic error for 5xx status codes and logs the details internally.
app.use((err, req, res, next) => {
  const traceId = crypto.randomUUID();
  // Log the full error internally for debugging
  console.error({ traceId, error: err.message, stack: err.stack });

  const problem: ProblemDetails = {
    type: '/errors/internal-server-error',
    title: 'Internal Server Error',
    status: 500,
    detail: `An unexpected error occurred. Please use this trace ID when reporting the issue: ${traceId}`,
    instance: req.originalUrl,
    traceId: traceId,
  };
  res.status(500).contentType('application/problem+json').json(problem);
});
```

### 7. Code Review Checklist

- [ ] Are all error responses using the `ProblemDetails` format (`application/problem+json`)?
- [ ] Is the HTTP status code accurate for the type of error?
- [ ] Is a `type` URI provided, and does it point to useful documentation?
- [ ] Is the `detail` message clear, concise, and free of jargon?
- [ ] Are there any paths that could expose stack traces or other sensitive data in production?
- [ ] For validation errors, is `422 Unprocessable Entity` used with an `invalid-params` extension?
- [ ] Is a correlation ID (`traceId`) included in all error responses?
- [ ] Does the error handling middleware correctly distinguish between 4xx and 5xx errors?

### 8. Related Skills

- `api-design-rest-graphql`
- `express-rest-api`
- `nestjs-modules`
- `data-sanitization`
- `owasp-top-10`

### 9. Examples Directory Structure

```
examples/
├── express-middleware.ts
├── nestjs-exception-filter.ts
├── custom-error-classes.ts
└── validation-error-response.json
```

### 10. Custom Scripts Section

Here are 3-5 automation scripts that can significantly help developers working with standardized API error responses.

1.  **`generate-error-handler`**: A script that bootstraps a complete error handling module for a Node.js framework (Express, NestJS, Fastify). It generates custom error classes, the Problem Details interface, and a global error handling middleware/filter.
2.  **`validate-error-spec`**: A linter that crawls OpenAPI/Swagger specification files (`openapi.yaml`) and checks if all defined error responses (4xx/5xx) conform to the RFC 9457 standard. It flags non-compliant response schemas.
3.  **`create-error-type`**: A CLI tool to quickly scaffold a new error type. It prompts for the `type` URI, `title`, and `status`, then generates a custom error class and a corresponding markdown file for the documentation (`/docs/errors/...`).
