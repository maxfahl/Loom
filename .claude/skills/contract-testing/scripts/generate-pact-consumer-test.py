#!/usr/bin/env python3
"""
generate-pact-consumer-test.py

Generates a boilerplate Pact consumer test file (.pact.spec.ts) for a given service.

This script helps automate the creation of new consumer-side contract tests,
reducing boilerplate and ensuring a consistent starting structure.

Usage:
    python generate-pact-consumer-test.py --consumer MyFrontend --provider MyBackend --service UserService
    python generate-pact-consumer-test.py -c "OrderServiceConsumer" -p "ProductService" -s "Product" -o "./src/tests"

Features:
- Takes consumer name, provider name, and service name as input.
- Creates the test file with necessary Pact imports and setup.
- Includes a basic interaction block as a starting point.
- Supports specifying an output directory.
- Includes error handling and help text.
"""

import argparse
import os
from datetime import datetime

def generate_pact_consumer_test(consumer_name: str, provider_name: str, service_name: str, output_dir: str):
    """
    Generates the content for a Pact consumer test file.
    """
    file_content = f"""// {service_name.lower()}-service.pact.spec.ts
// Generated by generate-pact-consumer-test.py on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

import {{ PactV3, MatchersV3 }} from '@pact-foundation/pact';
import {{ resolve }} from 'path';
// Assuming your API client is in a similar path relative to the test file
import {{ {service_name}Service }} from '../src/{service_name.lower()}-service';

const {{ like, eachLike, term }} = MatchersV3;

// Define the Pact mock service
const provider = new PactV3({{
  consumer: '{consumer_name}',
  provider: '{provider_name}',
  port: 8080, // Default port for Pact mock service
  logLevel: 'debug',
  dir: resolve(process.cwd(), 'pact/interactions'), // Directory to store generated pact files
}});

describe('{service_name}Service API Contract', () => {{
  // Start the mock service before all tests
  beforeAll(() => provider.start());

  // Verify the interactions and write the pact file after all tests
  afterAll(() => provider.finalize());

  // Ensure the mock service is reset before each test
  afterEach(() => provider.verify());

  describe('getting a {service_name.lower()} by ID', () => {{
    it('should return a {service_name.lower()} with expected structure', async () => {{
      // Define the expected interaction
      await provider.addInteraction({{
        uponReceiving: 'a request for {service_name.lower()} 1',
        withRequest: {{
          method: 'GET',
          path: '/{service_name.lower()}s/1',
          headers: {{ 'Accept': 'application/json' }},
        }},
        willRespondWith: {{
          status: 200,
          headers: {{ 'Content-Type': 'application/json' }},
          body: like({{
            id: like(1),
            name: term({{
              matcher: '[A-Za-z ]+',
              generate: '{service_name} Name',
            }}),
            // Add other expected fields with appropriate matchers
            // email: term({ matcher: '\w+@\w+\.\w+', generate: 'test@{service_name.lower()}.com' }),
          }}),
        }},
      }});

      // Execute the consumer code that makes the request
      await provider.executeTest(async (mockService) => {{
        const {service_name.lower()}Service = new {service_name}Service(mockService.url);
        const result = await {service_name.lower()}Service.get{service_name}(1);

        // Assertions on the response from the mock service
        expect(typeof result.id).toBe('number');
        expect(typeof result.name).toBe('string');
        // Add other assertions based on your contract
      }});
    }});
  }});

  // Add more describe blocks for other API endpoints/interactions
}});"""
    return file_content

def main():
    parser = argparse.ArgumentParser(
        description="Generates a boilerplate Pact consumer test file for a given service.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "-c", "--consumer",
        required=True,
        help="The name of the consumer application (e.g., 'FrontendApp')."
    )
    parser.add_argument(
        "-p", "--provider",
        required=True,
        help="The name of the provider service (e.g., 'UserService')."
    )
    parser.add_argument(
        "-s", "--service",
        required=True,
        help="The name of the service class/entity (e.g., 'User', 'Product'). Used for file naming and class names."
    )
    parser.add_argument(
        "-o", "--output-dir",
        default="./.devdev/skills/contract-testing/examples/consumer/tests",
        help="The output directory for the generated test file. Defaults to './.devdev/skills/contract-testing/examples/consumer/tests'."
    )

    args = parser.parse_args()

    # Ensure output directory exists
    os.makedirs(args.output_dir, exist_ok=True)

    file_name = f"{args.service.lower()}-service.pact.spec.ts"
    file_path = os.path.join(args.output_dir, file_name)

    if os.path.exists(file_path):
        print(f"Error: File '{file_path}' already exists. Please remove it or choose a different service name.")
        exit(1)

    content = generate_pact_consumer_test(args.consumer, args.provider, args.service, args.output_dir)

    try:
        with open(file_path, "w") as f:
            f.write(content)
        print(f"Successfully generated Pact consumer test file: {file_path}")
    except IOError as e:
        print(f"Error writing file {file_path}: {e}")
        exit(1)

if __name__ == "__main__":
    main()
