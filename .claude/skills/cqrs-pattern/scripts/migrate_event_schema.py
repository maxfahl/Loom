import argparse
import os
import re
import sys

def to_kebab_case(name):
    return name.replace(' ', '-').lower()

def to_pascal_case(name):
    return ''.join(word.capitalize() for word in name.split('-'))

def generate_event_migration_script(event_name_kebab, event_name_pascal, old_version, new_version, output_dir, original_event_content):
    old_event_interface_name = f"{event_name_pascal}EventV{old_version}"
    new_event_interface_name = f"{event_name_pascal}EventV{new_version}"
    
    # Extract properties from the original event content to suggest for the new version
    properties = []
    for line in original_event_content.splitlines():
        match = re.match(r'^\s*(readonly\s+)?(\w+)\s*\??:\s*([^;]+);.*$', line)
        if match:
            prop_name = match.group(2)
            prop_type = match.group(3).strip()
            properties.append(f"  readonly {prop_name}: {prop_type};")

    new_event_interface_body = "\n".join(properties) if properties else "  // TODO: Define new event payload properties for V{new_version}"

    content = f"// {output_dir}/events/{event_name_kebab}.event.v{new_version}.ts
// This file was generated by the event schema migrator script.
// It represents version {new_version} of the {event_name_pascal}Event.

import {{ {old_event_interface_name} }} from './{event_name_kebab}.event.v{old_version}';

export interface {new_event_interface_name} {{
  readonly type: '{event_name_pascal}'; // Event type remains consistent
  readonly aggregateId: string;
  readonly timestamp: Date;
{new_event_interface_body}
}}

/**
 * Migrates an event from version V{old_version} to V{new_version}.
 * Implement the logic to transform the old event structure to the new one.
 * Handle any new fields (e.g., provide default values) or removed fields.
 */
export function migrate{event_name_pascal}EventV{old_version}ToV{new_version}(
  oldEvent: {old_event_interface_name}
): {new_event_interface_name} {
  // TODO: Implement migration logic here.
  // Example: Add a new field with a default value, or transform existing fields.
  return {{
    ...oldEvent,
    // Example of adding a new field:
    // newField: 'defaultValue',
    // Example of transforming an existing field:
    // someField: oldEvent.oldSomeField.toString(),
  }} as {new_event_interface_name};
}}
"
    return f"events/{event_name_kebab}.event.v{new_version}.ts", content

def create_file(filepath, content, dry_run):
    if dry_run:
        print(f"Would create file: {filepath}")
        print("-" * 20)
        print(content)
        print("-" * 20)
        return

    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    if os.path.exists(filepath):
        print(f"File already exists: {filepath}. Skipping.", file=sys.stderr)
        return
    with open(filepath, 'w') as f:
        f.write(content)
    print(f"Created file: {filepath}")

def main():
    parser = argparse.ArgumentParser(
        description="Generate a new version of an event schema and a migration function.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "event_name",
        help="Base name of the event (e.g., 'UserCreated')."
    )
    parser.add_argument(
        "old_version",
        type=int,
        help="Current version number of the event (e.g., 1 for V1)."
    )
    parser.add_argument(
        "new_version",
        type=int,
        help="New version number for the event (e.g., 2 for V2)."
    )
    parser.add_argument(
        "--output-dir",
        default=".",
        help="Base output directory for generated files (e.g., 'src/domain/events')."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print what would be done without actually creating files."
    )

    args = parser.parse_args()

    if args.new_version <= args.old_version:
        print("Error: New version must be greater than old version.", file=sys.stderr)
        sys.exit(1)

    event_name_kebab = to_kebab_case(args.event_name)
    event_name_pascal = to_pascal_case(event_name_kebab)
    
    base_output_dir = os.path.abspath(args.output_dir)
    
    # Construct path to the old event file
    old_event_filepath_relative = f"events/{event_name_kebab}.event.v{args.old_version}.ts"
    old_event_filepath_absolute = os.path.join(base_output_dir, old_event_filepath_relative)

    original_event_content = ""
    if os.path.exists(old_event_filepath_absolute):
        with open(old_event_filepath_absolute, 'r') as f:
            original_event_content = f.read()
    else:
        print(f"Warning: Original event file not found at {old_event_filepath_absolute}. "
              f"Generating new event interface without existing properties.", file=sys.stderr)

    new_event_file_relative, new_event_file_content = generate_event_migration_script(
        event_name_kebab, event_name_pascal, args.old_version, args.new_version, base_output_dir, original_event_content
    )
    new_event_file_absolute = os.path.join(base_output_dir, new_event_file_relative)
    
    create_file(new_event_file_absolute, new_event_file_content, args.dry_run)

if __name__ == "__main__":
    main()
