#!/usr/bin/env python3

# docker-secret-template.py
# Description: Generates a .env.template file from a given Dockerfile or docker-compose.yaml
#              by extracting ENV variables and ARGs, prompting the user for descriptions,
#              and ensuring no sensitive defaults are exposed.
# Usage: python3 docker-secret-template.py <path_to_dockerfile_or_compose>
#        python3 docker-secret-template.py ./Dockerfile
#        python3 docker-secret-template.py ./docker-compose.yaml

import argparse
import os
import re
import sys
import yaml

# --- Helper Functions ---
def print_info(message): print(f"\033[0;34m[INFO]\033[0m {message}")
def print_success(message): print(f"\033[0;32m[SUCCESS]\033[0m {message}")
def print_warning(message): print(f"\033[0;33m[WARNING]\033[0m {message}")
def print_error(message): print(f"\033[0;31m[ERROR]\033[0m {message}")

def get_user_input(prompt, default=None):
    input_prompt = f"\033[0;36m{prompt}\033[0m "
    if default is not None:
        input_prompt += f"(default: {default}) "
    response = input(input_prompt).strip()
    return response if response else default

def extract_from_dockerfile(file_path):
    env_vars = {}
    arg_vars = {}
    with open(file_path, 'r') as f:
        for line in f:
            # Extract ENV variables
            match_env = re.match(r'^ENV\s+([A-Z_]+)=(.+)', line.strip())
            if match_env:
                key, value = match_env.groups()
                env_vars[key] = value
            # Extract ARG variables
            match_arg = re.match(r'^ARG\s+([A-Z_]+)(?:=(.+))?', line.strip())
            if match_arg:
                key, value = match_arg.groups()
                arg_vars[key] = value if value is not None else ""
    return env_vars, arg_vars

def extract_from_docker_compose(file_path):
    env_vars = {}
    try:
        with open(file_path, 'r') as f:
            compose_config = yaml.safe_load(f)

        if not compose_config or 'services' not in compose_config:
            return env_vars

        for service_name, service_config in compose_config['services'].items():
            if 'environment' in service_config:
                for env_item in service_config['environment']:
                    if isinstance(env_item, str) and '=' in env_item:
                        key, value = env_item.split('=', 1)
                        env_vars[key] = value
                    elif isinstance(env_item, dict):
                        env_vars.update(env_item)

    except yaml.YAMLError as e:
        print_error(f"Error parsing YAML file {file_path}: {e}")
        sys.exit(1)
    except FileNotFoundError:
        print_error(f"File not found: {file_path}")
        sys.exit(1)
    return env_vars

def main():
    parser = argparse.ArgumentParser(
        description="Generates a .env.template file from Dockerfile or docker-compose.yaml."
    )
    parser.add_argument(
        "file_path",
        help="Path to the Dockerfile or docker-compose.yaml file."
    )
    parser.add_argument(
        '--output', '-o',
        default='.env.template',
        help="Output file name for the .env template (default: .env.template)"
    )
    parser.add_argument(
        '--dry-run', action='store_true',
        help="Print the generated content to stdout instead of writing to file."
    )
    args = parser.parse_args()

    input_file_path = args.file_path
    output_file_name = args.output

    if not os.path.exists(input_file_path):
        print_error(f"Input file not found: {input_file_path}")
        sys.exit(1)

    extracted_vars = {}
    if "dockerfile" in input_file_path.lower():
        env_vars, arg_vars = extract_from_dockerfile(input_file_path)
        extracted_vars.update(env_vars)
        extracted_vars.update(arg_vars)
        print_info(f"Extracted variables from Dockerfile: {input_file_path}")
    elif "docker-compose" in input_file_path.lower():
        env_vars = extract_from_docker_compose(input_file_path)
        extracted_vars.update(env_vars)
        print_info(f"Extracted variables from Docker Compose file: {input_file_path}")
    else:
        print_error("Unsupported file type. Please provide a Dockerfile or docker-compose.yaml.")
        sys.exit(1)

    if not extracted_vars:
        print_warning("No environment variables or build arguments found to template.")
        sys.exit(0)

    template_lines = ["# .env.template - Environment variables for development"]
    template_lines.append("# Generated by docker-secret-template.py. Fill in your values.")
    template_lines.append("# Sensitive values should NOT be committed to version control.")
    template_lines.append("")

    for key, default_value in extracted_vars.items():
        print_info(f"Processing variable: {key}")
        description = get_user_input(f"Enter a description for {key}", default=f"Description for {key}")
        template_lines.append(f"# {description}")

        # Mask potentially sensitive default values
        if default_value and ("PASSWORD" in key.upper() or "SECRET" in key.upper() or "KEY" in key.upper()):
            template_lines.append(f"{key}=") # Leave sensitive values blank
        else:
            template_lines.append(f"{key}={default_value}")
        template_lines.append("")

    template_content = "\n".join(template_lines)

    if args.dry_run:
        print_info("Dry run: Generated .env.template content:")
        print(template_content)
    else:
        if os.path.exists(output_file_name):
            print_warning(f"'{output_file_name}' already exists. Overwrite? (y/N)")
            if get_user_input("", default='n').lower() != 'y':
                print_info("Aborting. File not overwritten.")
                sys.exit(0)
        try:
            with open(output_file_name, 'w') as f:
                f.write(template_content)
            print_success(f"Successfully generated '{output_file_name}'.")
            print_info("Remember to fill in the values and rename it to .env for local use.")
        except IOError as e:
            print_error(f"Error writing to file '{output_file_name}': {e}")
            sys.exit(1)

if __name__ == "__main__":
    main()
