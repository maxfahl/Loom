import argparse
import json
import os
import sys
from datetime import datetime

# ANSI escape codes for colored output
COLOR_RED = "\033[91m"
COLOR_GREEN = "\033[92m"
COLOR_YELLOW = "\033[93m"
COLOR_BLUE = "\033[94m"
COLOR_RESET = "\033[0m"

def print_color(color, message):
    print(f"{color}{message}{COLOR_RESET}")

class Vulnerability:
    def __init__(self, data):
        self.id = data.get('id', 'N/A')
        self.name = data.get('name', 'Unknown Vulnerability')
        self.description = data.get('description', 'No description provided.')
        self.severity = data.get('severity', 'Medium')
        self.cvss_score = data.get('cvss_score', 0.0)
        self.exploitability = data.get('exploitability', 'Medium')
        self.business_impact = data.get('business_impact', 'Medium')
        self.affected_component = data.get('affected_component', 'N/A')
        self.status = data.get('status', 'Open')
        self.owner = data.get('owner', 'Unassigned')
        self.priority_score = self._calculate_priority_score()

    def _calculate_priority_score(self):
        # Simple prioritization logic: CVSS score is primary, then severity, then exploitability, then business impact
        score = self.cvss_score

        severity_map = {'Critical': 5, 'High': 4, 'Medium': 3, 'Low': 2, 'Informational': 1}
        exploitability_map = {'High': 3, 'Medium': 2, 'Low': 1, 'N/A': 0}
        business_impact_map = {'High': 3, 'Medium': 2, 'Low': 1, 'N/A': 0}

        score += severity_map.get(self.severity, 0) * 1.0 # Weight severity
        score += exploitability_map.get(self.exploitability, 0) * 0.5 # Weight exploitability
        score += business_impact_map.get(self.business_impact, 0) * 0.7 # Weight business impact

        return score

    def __repr__(self):
        return f"Vulnerability(ID={self.id}, Name={self.name}, Priority={self.priority_score}, Status={self.status})"

def load_vulnerabilities(file_path):
    """Loads vulnerability data from a JSON file."""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
        return [Vulnerability(item) for item in data]
    except FileNotFoundError:
        print_color(COLOR_RED, f"Error: Vulnerability file not found at {file_path}")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print_color(COLOR_RED, f"Error decoding JSON from {file_path}: {e}")
        sys.exit(1)
    except Exception as e:
        print_color(COLOR_RED, f"Error loading vulnerabilities from {file_path}: {e}")
        sys.exit(1)

def generate_vulnerability_report(vuln_file, output_file, min_priority, filter_status, filter_owner, dry_run):
    """Generates a prioritized vulnerability report."""
    print_color(COLOR_YELLOW, f"Generating vulnerability report from: {vuln_file}")

    vulnerabilities = load_vulnerabilities(vuln_file)

    if not vulnerabilities:
        print_color(COLOR_YELLOW, "No vulnerabilities found in the input file.")
        return

    # Filter vulnerabilities
    filtered_vulnerabilities = []
    for vuln in vulnerabilities:
        if vuln.priority_score < min_priority:
            continue
        if filter_status and vuln.status.lower() != filter_status.lower():
            continue
        if filter_owner and vuln.owner.lower() != filter_owner.lower():
            continue
        filtered_vulnerabilities.append(vuln)

    # Sort by priority score (descending)
    sorted_vulnerabilities = sorted(filtered_vulnerabilities, key=lambda x: x.priority_score, reverse=True)

    report_content = []
    report_content.append(f"# Vulnerability Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    report_content.append(f"Generated from: {vuln_file}\n")
    report_content.append(f"Minimum Priority Score for Inclusion: {min_priority:.2f}\n")
    if filter_status: report_content.append(f"Filtered by Status: {filter_status}\n")
    if filter_owner: report_content.append(f"Filtered by Owner: {filter_owner}\n")
    report_content.append(f"Total Vulnerabilities Identified: {len(vulnerabilities)}\n")
    report_content.append(f"Vulnerabilities in Report: {len(sorted_vulnerabilities)}\n")
    report_content.append("---\n\n")

    if not sorted_vulnerabilities:
        report_content.append("No vulnerabilities matching the criteria to report.\n")
    else:
        for vuln in sorted_vulnerabilities:
            report_content.append(f"## {vuln.name} ({vuln.id})\n")
            report_content.append(f"- **Priority Score:** {vuln.priority_score:.2f}\n")
            report_content.append(f"- **Severity:** {vuln.severity}\n")
            report_content.append(f"- **CVSS Score:** {vuln.cvss_score}\n")
            report_content.append(f"- **Exploitability:** {vuln.exploitability}\n")
            report_content.append(f"- **Business Impact:** {vuln.business_impact}\n")
            report_content.append(f"- **Affected Component:** {vuln.affected_component}\n")
            report_content.append(f"- **Status:** {vuln.status}\n")
            report_content.append(f"- **Owner:** {vuln.owner}\n")
            report_content.append(f"- **Description:** {vuln.description}\n")
            report_content.append("\n")

    final_report = "".join(report_content)

    if dry_run:
        print_color(COLOR_YELLOW, "\n--- Dry Run Vulnerability Report Output ---")
        print(final_report)
        print_color(COLOR_YELLOW, "--- End Dry Run ---")
    else:
        if output_file:
            try:
                with open(output_file, 'w') as f:
                    f.write(final_report)
                print_color(COLOR_GREEN, f"Vulnerability report successfully written to {output_file}")
            except Exception as e:
                print_color(COLOR_RED, f"Error writing vulnerability report to {output_file}: {e}")
                sys.exit(1)
        else:
            print_color(COLOR_GREEN, "\n--- Generated Vulnerability Report ---")
            print(final_report)
            print_color(COLOR_GREEN, "--- End Vulnerability Report ---")

    print_color(COLOR_GREEN, "Vulnerability report generation complete.")

def main():
    parser = argparse.ArgumentParser(
        description="Generate a prioritized vulnerability report from a JSON input file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "-f", "--file",
        required=True,
        help="Path to the JSON file containing vulnerability data."
    )
    parser.add_argument(
        "-o", "--output",
        help="Output file path for the report (e.g., vuln_report.md). If not specified, prints to stdout."
    )
    parser.add_argument(
        "-p", "--min-priority",
        type=float,
        default=0.0,
        help="Minimum calculated priority score for a vulnerability to be included in the report (default: 0.0)."
    )
    parser.add_argument(
        "-s", "--status",
        help="Filter vulnerabilities by status (e.g., 'Open', 'Triaged'). Case-insensitive."
    )
    parser.add_argument(
        "-w", "--owner",
        help="Filter vulnerabilities by owner (e.g., 'security-team'). Case-insensitive."
    )
    parser.add_argument(
        "-d", "--dry-run",
        action="store_true",
        help="Show the report output without writing to a file."
    )

    args = parser.parse_args()

    generate_vulnerability_report(args.file, args.output, args.min_priority, args.status, args.owner, args.dry_run)

if __name__ == "__main__":
    main()
