import argparse
import sys
import yaml

# ANSI escape codes for colored output
COLOR_GREEN = '\033[92m'
COLOR_RED = '\033[91m'
COLOR_YELLOW = '\033[93m'
COLOR_BLUE = '\033[94m'
COLOR_RESET = '\033[0m'

def generate_kubernetes_config(
    app_name: str,
    image: str,
    port: int,
    replicas: int,
    strategy: str,
    version_label: str,
    output_file: str | None = None,
) -> None:
    """
    Generates a basic Kubernetes Deployment and Service YAML configuration.

    Args:
        app_name: The name of the application.
        image: The Docker image to use for the deployment.
        port: The container port the application listens on.
        replicas: The number of replicas for the deployment.
        strategy: The deployment strategy (e.g., 'blue-green', 'canary', 'rolling').
        version_label: The initial version label for the deployment (e.g., 'v1', 'blue').
        output_file: Optional. The file path to write the YAML output to. If None, prints to stdout.
    """
    print(f"{COLOR_BLUE}--- Kubernetes Deployment Config Generator ---{COLOR_RESET}")
    print(f"Generating config for application: {COLOR_YELLOW}{app_name}{COLOR_RESET}")
    print(f"Image: {COLOR_YELLOW}{image}{COLOR_RESET}")
    print(f"Port: {COLOR_YELLOW}{port}{COLOR_RESET}")
    print(f"Replicas: {COLOR_YELLOW}{replicas}{COLOR_RESET}")
    print(f"Strategy: {COLOR_YELLOW}{strategy}{COLOR_RESET}")
    print(f"Initial Version Label: {COLOR_YELLOW}{version_label}{COLOR_RESET}")
    print("----------------------------------------------")

    # Deployment YAML
    deployment_yaml = {
        "apiVersion": "apps/v1",
        "kind": "Deployment",
        "metadata": {
            "name": f"{app_name}-{version_label}",
            "labels": {
                "app": app_name,
                "version": version_label,
            },
        },
        "spec": {
            "replicas": replicas,
            "selector": {
                "matchLabels": {
                    "app": app_name,
                    "version": version_label,
                }
            },
            "template": {
                "metadata": {
                    "labels": {
                        "app": app_name,
                        "version": version_label,
                    }
                },
                "spec": {
                    "containers": [
                        {
                            "name": app_name,
                            "image": image,
                            "ports": [
                                {
                                    "containerPort": port,
                                }
                            ],
                        }
                    ]
                },
            },
        },
    }

    # Service YAML
    service_yaml = {
        "apiVersion": "v1",
        "kind": "Service",
        "metadata": {
            "name": f"{app_name}-service",
            "labels": {
                "app": app_name,
            },
        },
        "spec": {
            "selector": {
                "app": app_name,
                "version": version_label,  # Initially points to the specified version
            },
            "ports": [
                {
                    "protocol": "TCP",
                    "port": 80,  # External service port
                    "targetPort": port,  # Internal container port
                }
            ],
            "type": "LoadBalancer",  # Or ClusterIP for internal services
        },
    }

    output_content = """
# Kubernetes Deployment for {app_name} (Version: {version_label})
# Generated by deployment-config-generator.py
""" + yaml.dump(deployment_yaml, sort_keys=False) + """

---

# Kubernetes Service for {app_name}
# Generated by deployment-config-generator.py
""" + yaml.dump(service_yaml, sort_keys=False)

    if output_file:
        try:
            with open(output_file, "w") as f:
                f.write(output_content)
            print(f"{COLOR_GREEN}Configuration successfully written to {output_file}{COLOR_RESET}")
        except IOError as e:
            print(f"{COLOR_RED}Error writing to file {output_file}: {e}{COLOR_RESET}")
            sys.exit(1)
    else:
        print(f"{COLOR_GREEN}\n--- Generated Kubernetes Configuration ---{COLOR_RESET}")
        print(output_content)
        print(f"{COLOR_GREEN}------------------------------------------{COLOR_RESET}")

def main():
    parser = argparse.ArgumentParser(
        description="Generates a basic Kubernetes Deployment and Service YAML configuration.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "--app-name",
        type=str,
        required=True,
        help="The name of the application (e.g., 'my-webapp').",
    )
    parser.add_argument(
        "--image",
        type=str,
        required=True,
        help="The Docker image to use for the deployment (e.g., 'nginx:latest', 'myrepo/my-app:v1').",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=80,
        help="The container port the application listens on. Default: 80.",
    )
    parser.add_argument(
        "--replicas",
        type=int,
        default=3,
        help="The number of replicas for the deployment. Default: 3.",
    )
    parser.add_argument(
        "--strategy",
        type=str,
        choices=["blue-green", "canary", "rolling"],
        default="rolling",
        help="The intended deployment strategy. Affects initial labeling. Default: rolling.",
    )
    parser.add_argument(
        "--version-label",
        type=str,
        default="v1",
        help="The initial version label for the deployment (e.g., 'v1', 'blue', 'canary'). Default: v1.",
    )
    parser.add_argument(
        "--output-file",
        type=str,
        help="Optional. The file path to write the YAML output to. If not provided, prints to stdout.",
    )

    args = parser.parse_args()

    generate_kubernetes_config(
        app_name=args.app_name,
        image=args.image,
        port=args.port,
        replicas=args.replicas,
        strategy=args.strategy,
        version_label=args.version_label,
        output_file=args.output_file,
    )

if __name__ == "__main__":
    main()
