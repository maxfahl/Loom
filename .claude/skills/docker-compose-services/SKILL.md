---
Name: docker-compose-services
Version: 1.0.0
Category: DevOps / Container Orchestration
Tags: Docker Compose, Multi-container, YAML, Development, Production, Environment Management
Description: Defines and manages multi-container Docker applications for development and production environments.
---

# Docker Compose Services

## 1. Skill Purpose

This skill empowers users to efficiently define, run, and manage multi-container Docker applications using Docker Compose. It focuses on best practices for structuring `docker-compose.yml` files, managing environments, ensuring data persistence, securing sensitive information, and optimizing for both development and production workflows. By leveraging Docker Compose effectively, users can create reproducible, isolated, and scalable local development environments and streamline deployment processes.

## 2. When to Activate This Skill

Activate this skill when the user's request involves:
*   Setting up a multi-container local development environment.
*   Defining application services, networks, and volumes using `docker-compose.yml`.
*   Managing environment-specific configurations for Dockerized applications.
*   Handling secrets and sensitive data within a Docker Compose setup.
*   Ensuring data persistence for stateful services (e.g., databases).
*   Scaling services in a local or small-scale production environment.
*   Troubleshooting Docker Compose configurations.
*   Keywords: "Docker Compose", "multi-container application", "docker-compose.yml", "manage Docker services", "development environment with Docker", "production deployment with Docker Compose", "Docker Compose secrets", "Docker Compose networking", "Docker Compose volumes", "Docker Compose healthcheck".

## 3. Core Knowledge

Claude needs to understand the following fundamental concepts related to Docker Compose services:

*   **`docker-compose.yml` Structure**: The top-level elements: `services`, `networks`, `volumes`, `configs`, and `secrets`. Understanding how these sections define the application stack.
*   **Service Definition**: Key directives within a service block:
    *   `image`: Specifying the Docker image to use.
    *   `build`: Defining how to build a custom image from a Dockerfile.
    *   `ports`: Mapping host ports to container ports.
    *   `volumes`: Mounting host paths or named volumes for data persistence.
    *   `environment`: Setting environment variables within the container.
    *   `env_file`: Loading environment variables from a file.
    *   `depends_on`: Defining service startup order (for dependency resolution).
    *   `healthcheck`: Defining commands to check if a container is healthy and ready.
    *   `restart`: Configuring container restart policies.
    *   `networks`: Attaching services to specific networks.
    *   `deploy`: (For Swarm mode) Defining deployment constraints, replicas, resources.
    *   `configs` and `secrets`: Mounting external configuration and secret files into services.
*   **Environment Management**: 
    *   Using `.env` files for non-sensitive variables that are specific to the deployment environment.
    *   Understanding environment variable precedence (CLI > Shell > Compose file `environment` > `.env` file > Compose file `env_file`).
    *   Employing multiple Compose files (`docker-compose.yml`, `docker-compose.dev.yml`, `docker-compose.prod.yml`) for environment-specific overrides.
*   **Data Persistence**: 
    *   **Named Volumes**: The preferred way to persist data generated by Docker containers, managed by Docker.
    *   **Bind Mounts**: Mounting a file or directory from the host machine into a container, useful for development (e.g., hot-reloading code).
*   **Networking**: 
    *   **Default Network**: Docker Compose creates a default bridge network for services.
    *   **Custom Networks**: Defining explicit networks for better isolation and organization.
    *   **Service Discovery**: Services can communicate by their service names within the same network.
*   **Secrets Management**: 
    *   **Docker Secrets**: Built-in mechanism for managing sensitive data in Docker Swarm mode.
    *   **External Secret Management**: Integrating with tools like HashiCorp Vault or Kubernetes Secrets (when moving beyond Compose).
*   **Health Checks**: Crucial for ensuring that services are not just running, but are actually ready to accept connections and perform their functions.
*   **Resource Management**: Setting `cpu_shares`, `mem_limit`, `mem_reservation` to prevent resource exhaustion and ensure fair resource allocation.

## 4. Key Guidance for Claude

### Always Recommend (✅ Best Practices)

*   **✅ Use Multiple Compose Files for Environments**: Structure your project with a base `docker-compose.yml` for common configurations and separate override files (e.g., `docker-compose.dev.yml`, `docker-compose.prod.yml`) for environment-specific settings. This promotes DRY and flexibility.
    ```yaml
    # docker-compose.yml (base configuration)
    services:
      web:
        image: myapp:latest
        build: .
        ports:
          - "80:80"
        volumes:
          - app_data:/app/data

    # docker-compose.dev.yml (development overrides)
    services:
      web:
        build:
          context: .
          dockerfile: Dockerfile.dev
        volumes:
          - ./src:/app/src # Bind mount for hot-reloading
        environment:
          NODE_ENV: development
        ports:
          - "3000:3000"

    # Usage: docker compose -f docker-compose.yml -f docker-compose.dev.yml up
    ```
*   **✅ Utilize `.env` Files for Non-Sensitive Variables**: Store non-sensitive, environment-specific variables (e.g., default ports, non-secret API keys) in a `.env` file at the root of your project. **Always add `.env` to `.gitignore`**.
    ```dotenv
    # .env example
    APP_PORT=3000
    DB_HOST=database
    DB_NAME=mydatabase
    ```
*   **✅ Securely Manage Sensitive Data**: Never hardcode secrets (database passwords, API keys) directly in `docker-compose.yml` or commit them in `.env` files. For production, use Docker Secrets (if using Swarm) or external secret management solutions. For local development, use `docker-compose.yml` `secrets` section with external files or environment variables that are not committed.
    ```yaml
    # docker-compose.yml (using secrets for production/staging)
    services:
      db:
        image: postgres:15-alpine
        environment:
          POSTGRES_PASSWORD_FILE: /run/secrets/db_password
        secrets:
          - db_password
    secrets:
      db_password:
        file: ./db_password.txt # This file should NOT be committed to VCS
    ```
*   **✅ Define Robust Health Checks**: Implement `healthcheck` directives for all critical services (especially databases and APIs) to ensure they are truly ready before dependent services start or traffic is routed. This prevents race conditions and improves application resilience.
    ```yaml
    services:
      db:
        image: postgres:15-alpine
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U postgres"]
          interval: 5s
          timeout: 5s
          retries: 5
      web:
        image: myapp:latest
        depends_on:
          db:
            condition: service_healthy # Wait for DB to be healthy
    ```
*   **✅ Use Named Volumes for Data Persistence**: For stateful services (databases, caches), always use named volumes to ensure data persists even if containers are removed or recreated. Avoid bind mounts for production data.
    ```yaml
    services:
      db:
        image: postgres:15-alpine
        volumes:
          - db_data:/var/lib/postgresql/data
    volumes:
      db_data:
    ```
*   **✅ Define Custom Networks for Isolation**: Create explicit networks for your services. This provides better isolation, clearer communication paths, and prevents accidental exposure.
    ```yaml
    services:
      web:
        networks:
          - frontend
      api:
        networks:
          - frontend
          - backend
      db:
        networks:
          - backend
    networks:
      frontend:
      backend:
    ```
*   **✅ Set Resource Limits**: Define `deploy.resources.limits` for CPU and memory for each service, especially in production-like environments, to prevent a single service from consuming all available resources and impacting others.
*   **✅ Pin Image Versions**: Always specify exact image tags (e.g., `postgres:15.3-alpine`) instead of `latest` or broad tags. This ensures reproducible builds and prevents unexpected breaking changes.
*   **✅ Direct Logs to `stdout`/`stderr`**: Ensure your application logs are written to `stdout` and `stderr` within the container. Docker Compose (and Docker itself) can then easily collect and manage these logs, integrating with external logging solutions.

### Never Recommend (❌ Anti-Patterns)

*   **❌ Hardcoding Secrets**: Never embed sensitive information directly into your `docker-compose.yml` file. This is a severe security vulnerability.
*   **❌ Using `latest` or Broad Tags in Production**: Avoid `image: myapp:latest` or `image: node:alpine` for production deployments. These tags are mutable and can lead to inconsistent environments and unexpected failures.
*   **❌ Relying on Default Networking for Complex Apps**: For anything beyond the simplest setups, explicitly define custom networks. Relying on the default bridge network can lead to naming conflicts and less clear communication.
*   **❌ Omitting Health Checks for Critical Services**: Not having health checks for services like databases or message queues can lead to dependent services starting prematurely and failing, causing cascading issues.
*   **❌ Running All Services as Root**: While Docker Compose doesn't directly control the `USER` directive in a Dockerfile, ensure that the images used for your services are configured to run as non-root users, following Docker best practices.
*   **❌ Using `version:` Field in Modern Compose Files**: Modern Docker Compose (v2 and later) no longer requires the `version:` field. Omitting it simplifies the file and indicates adherence to current standards.

### Common Questions & Responses

*   **Q: How do I manage different configurations for development, staging, and production environments with Docker Compose?**
    *   **A:** Use multiple Compose files. Create a base `docker-compose.yml` with common settings, and then create override files like `docker-compose.dev.yml` and `docker-compose.prod.yml` for environment-specific configurations. You can then use `docker compose -f docker-compose.yml -f docker-compose.dev.yml up`.
*   **Q: What's the best way to handle sensitive data like database passwords in Docker Compose?**
    *   **A:** For production, use Docker Secrets (if deploying to Swarm) or integrate with an external secret management system. For local development, you can use the `secrets` section in `docker-compose.yml` pointing to local files (ensure these files are `.gitignore`d) or pass them as environment variables from a `.env` file that is not committed.
*   **Q: My database container starts, but my application fails to connect. How can I ensure the database is ready?**
    *   **A:** Implement a `healthcheck` for your database service. Then, in your application service, use `depends_on` with `condition: service_healthy` to ensure your application only starts once the database reports itself as healthy.
*   **Q: How can I ensure my data isn't lost when I remove my database container?**
    *   **A:** Use named volumes for your database data. Define a volume in the `volumes` section of your `docker-compose.yml` and mount it to the appropriate path inside your database container (e.g., `/var/lib/postgresql/data` for PostgreSQL).

## 5. Anti-Patterns to Flag (Code Examples)

### ❌ Anti-Pattern: Hardcoded Secrets and `latest` Tags

```yaml
# ❌ BAD: Hardcoded password, using 'latest' tag
services:
  db:
    image: postgres:latest # ❌ Mutable 'latest' tag
    environment:
      POSTGRES_PASSWORD: mysecretpassword # ❌ Hardcoded secret
  web:
    image: myapp:latest
    environment:
      API_KEY: anotherhardcodedkey # ❌ Hardcoded secret
```
**Correction**: Pin image versions (e.g., `postgres:15.3-alpine`). Use Docker Secrets or external secret management for sensitive data. For local dev, use `.env` with `env_file` and ensure `.env` is `.gitignore`d.

### ❌ Anti-Pattern: No Health Checks for Critical Services

```yaml
# ❌ BAD: Web service starts before DB is ready, leading to connection errors
services:
  db:
    image: postgres:15-alpine
    # ❌ No healthcheck defined
  web:
    image: myapp:latest
    depends_on:
      - db # Only waits for container to start, not for service readiness
```
**Correction**: Add a `healthcheck` to the `db` service and use `condition: service_healthy` in the `web` service's `depends_on`.

### ❌ Anti-Pattern: Relying on Default Networking for Complex Apps

```yaml
# ❌ BAD: Implicit default network for all services
services:
  web:
    image: myapp:latest
    ports:
      - "80:80"
  api:
    image: myapi:latest
  db:
    image: postgres:15-alpine
# All services are on the same default bridge network, less clear and potentially less secure
```
**Correction**: Define explicit custom networks for better isolation and clearer communication paths.

## 6. Code Review Checklist

*   [ ] Are multiple `docker-compose.yml` files used for different environments (e.g., `docker-compose.yml`, `docker-compose.dev.yml`, `docker-compose.prod.yml`)?
*   [ ] Is a `.env` file used for non-sensitive environment variables, and is it excluded from version control (`.gitignore`)?
*   [ ] Are sensitive data (secrets) managed securely using Docker Secrets or an external secret management solution, and not hardcoded?
*   [ ] Are `healthcheck` directives defined for all critical services (e.g., databases, message queues, APIs)?
*   [ ] Are named volumes used for data persistence for stateful services?
*   [ ] Are custom networks defined for better service isolation and communication clarity?
*   [ ] Are resource limits (CPU, memory) set for services, especially in production-like configurations?
*   [ ] Are all Docker image versions explicitly pinned (e.g., `image: postgres:15.3-alpine`) instead of using `latest` or broad tags?
*   [ ] Are application logs directed to `stdout` and `stderr` within the containers?
*   [ ] Is the `version:` field omitted from the `docker-compose.yml` file (for modern Compose)?
*   [ ] Are `depends_on` conditions set to `service_healthy` for dependent services where appropriate?

## 7. Related Skills

*   `docker-best-practices`: Essential for building optimized and secure Docker images that are then used in Compose.
*   `ci-cd-pipelines`: For automating the deployment and management of Docker Compose applications.
*   `kubernetes-deployments`: Understanding how Compose concepts translate to larger-scale orchestration.
*   `linux-fundamentals`: For deeper understanding of containerization and networking.

## 8. Examples Directory Structure

```
docker-compose-services/
├── examples/
│   ├── web-app-db/
│   │   ├── docker-compose.yml
│   │   ├── docker-compose.dev.yml
│   │   ├── docker-compose.prod.yml
│   │   └── .env.example
├── patterns/
├── scripts/
└── README.md
```
